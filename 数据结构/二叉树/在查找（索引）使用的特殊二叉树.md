# 1. 二叉排序树（查找树，搜索树）

## 1.1 二叉查找树的定义

什么是二叉查找树呢？它是具有一下性质的二叉树（关于二叉树请看我关于[二叉树定义](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%2B%E5%9F%BA%E7%A1%80%E4%BA%8C%E5%8F%89%E6%A0%91%E8%AF%A6%E8%A7%A3.md)的内容）:

* 若它的左子树不为空，那么它的左子树上的所有结点的值都小于它的根结点的值
* 若它的右子树不为空，那么它的右子树上的所有结点的值都大于（现在实际索引的算法设计中是 >=）它的根结点的值
* 他的左右子树是二叉查找树
* 它属于一种**动态**查找表

注意：在实际运用中，这个值的比较的大小是看你怎么定义的，当然数值的大小是通用的（不排除你对其特殊的定义）

如图：

![1539839046436](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539839046436.png)

## 1.2 二叉查找树具有的一些特点

* 使用中序遍历得到的结果是排好序的，比如上图，使用中序遍历的结果一定是递增的顺序排列

* 一个结点的直接前驱（中序遍历后的结果序列中这个结点值的前面一个，比如上图，中序遍历结果`15,17,18,19,21,40....`,21这个结点的直接前驱就是19这个结点。）如果这个结点在树中有左子树，

  先转左，然后找右到尽头，一定是它的前驱，如果转左之后没有右，那这个左就是他的前驱，（还是上图的例子21这个结点有左子树吧，转左刀15，然后找右到尽头，18，19，最后就找到了19；在看18这个结点由左子树，我们转左找到17，但是由于没有右子树了，所以这个17就是18的直接前驱）

* 一个结点的直接后继：知道了直接前驱，那么直接后继就不需要过多说明了，和直接前驱的正好相反。

**介绍直接前驱后继这个特点主要是因为，删除这个操作的算法设计要用到这样一个特点**

## 1.3 二叉查找树的查找过程

**注意**：我们知道它是一种动态查找表，也就是说这个树中的结点是可以增改的。那么它的增删改的过程肯定也是会查找这个动作。

**当一个二叉查找树不为空的时候，如有一个给定值A和根节点的关键字作比较，若想等那么查找成功，否则根据A与当前根结点关键字的大小关系决定去左子树还是右子树进行查找。**

**通常我们使用二叉链表来作为二叉搜索树的存储结构**

## 1.4 优缺点

* 优点：

  * 从他的一个定义以及查找过程，能很容易的看出来，它也是一种二分搜索的实现，不过相比于顺序查找表，的结构以及访问方式它的优势就很大了，就算顺序表使用了二分查找，斐波那契查找，插值查找，也是比不了二分搜索树的查找效率的，但是这里不是说它就是最好的查找表，当然顺着发展，我们有了更多更好用，更加符合我们当前需求的查找结构，但是这个是基础，他可以帮助我们理解后面的发展出来的更好的用于查找的数据结构。
  * **二叉查找树使用中序遍历，是可以拿到一个排序好的的序列的。红黑树也有这样的性质（但是他对基础的这个二叉排序树的设计做了进一步改进），左子树比根节点小，右子树比根节点大。相信从这里你能看出，java中TreeMap是怎么排序的了**

* 缺点：这里有一个国外的数据结构的学习，了解网站，[Binary Search Tree](https://www.cs.usfca.edu/~galles/visualization/BST.html) 我在上面做了一下模拟，基于上文中的二叉排序树的图的内容，按照不同顺序插入：

  * `40,15,21,19,18，17`：进行到这我就没有在进行下去了，原因呢看图：

    ![1539840633788](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539840633788.png)

    我们在看我们原来的图深度是5，这里你会说，深度代表什么，那么我们用一个直观的例子来说 : 在原来的图的二叉搜索树中我们要查找17这个值，我们只需要经过5次判断，就可以确定这个值存在；在现在这个结构中呢，需要6次；这样我们就能只管的看出，二叉排序树的缺点了吧，**表中数据动态变化不可控，相同的数据按照不同的顺序传入，得到的结果大不相同，在现在的存储系统中大量用到索引，如果选择这样的结构的，绝对会成为检索的性能瓶颈，而且你要知道这个所用的动态改变，也是会先做检索，然后才增删改的，这样的结构做什么操作的性能在实际运用中都不会是好的选择**；

    下面我会再次用一个极端的例子，让你们更加深刻的理解到这种结构的问题，这里我们按照这样的顺序插入数据：`15，17，18，19，21，40，56，60，68，100`

    ![1539841346239](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539841346239.png)

    看到这个结果什么感受，所以这种结构只能作为一个理论基础，在实际运用中是不会采用的。 

## 1.5 二叉查找树的增删

增（insert）就不用说了吧，利用查找去做，然后没有别的特别的东西

这里主要说一下删(delete),为什么要说这个呢，是因为需要介绍在删除之后，要保持二叉排序树的中序遍历的结果中结点的前后顺序不变（这里就叫做稳定性了，后文中我都把它叫做稳点性）。

分下面三种情况讨论：（P代表双亲结点，PL代表它的左子树，PR代表它的右子树）

* 若结点 P 为叶子结点，删除叶子结点不破坏整个树的结构

* 若结点 P 只有左子树PL或者只有右子树PR，只需要将P的双亲结点指向P的指针指向PL或PR。

* 若左右子树不为空为了保证 “ 稳定性 ”，可以有两种做法，为了更加直观我们用一个树来演示：

  ![1539870820922](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539871115161.png)

  **中序遍历的结果：`29,35,36,37,47,49,51,56,58,62,73,88,99`**

  **假设这里我们要删除47**

  **注意观察树的深度变化**

  * 第一种是将P的双亲结点指向P的指针指向PL，将PR作为P的直接前驱的PR，结果：

    

    ![1539871310522](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539871310522.png)

    **树的深度是6**

  * 第二种做法是，令改结点P的直接前驱（或直接后继）替代P的位置，（查找直接前驱和后记的方法在上文1.2节当中有介绍），然后用这个直接前驱（直接后继）的双亲结点序接这个直接前驱（直接后继）的做子树或者右子树（这里我为什么用或呢？请你结合我前面说的前驱（后继）的特点来思考一下,虽然下文1.6节的算法代码中我有做说明），下面我分别给出用 前驱或后继 得到的结果图

    * 使用前驱得到的结果图

      ![1539872531318](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539872531318.png)

    * 使用后继得到的结果图

    ![1539872603495](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539872603495.png)

    **使用前驱（后继）两种方法修改的后二叉树的深度要么不变，要么减少（都会达到这样的效果）,显而易见，我们在实现的使用应该选择前驱（后继）的方式实现算法**

## 1.6 java 实现的删除树中一个结点的算法

* 使用前驱的算法：

  ```java
  public static BinaryLinkedNode delete(BinaryLinkedNode node) {
      BinaryLinkedNode temp = node;
      if (node.right == null) {
          // 右子树为空，只需要接上左子树
          node = node.left;
      } else if (node.right == null) {
          // 左子树为空，只需要接上右子树
          node = node.right;
      } else {
          // 左右子树都不为空
          BinaryLinkedNode pre = node.left;// 左转
          while (pre.right != null) {
              // 找右刀到尽头
              temp = pre;//用来记录 pre 的双亲
              pre = pre.right;
          }
          // 替换数据
          node.value = pre.value;
          if( temp == node ){
              // 就是说 左转之后由于没有右子树，那么左转的结点就是node的前驱了，那么只需要接上 pre 的左子树（可能有，也可能没有）
              temp.left = pre.left;
          }else{
              // 就是说 找右边到尽头之后，这个 pre 肯定没有右子树了，至于左子树有没有不知道但是，按照有来做
              temp.right = pre.left;
          }
      }
  }
  ```



* 使用后继的算法：

  ```java
  public static BinaryLinkedNode delete(BinaryLinkedNode node) {
      BinaryLinkedNode temp = node;
      if (node.right == null) {
          // 右子树为空，只需要接上左子树
          node = node.left;
      } else if (node.right == null) {
          // 左子树为空，只需要接上右子树
          node = node.right;
      } else {
          // 左右子树都不为空
          BinaryLinkedNode pre = node.left;// 左转
          while (pre.right != null) {
              // 找右刀到尽头
              temp = pre;//用来记录 pre 的双亲
              pre = pre.right;
          }
          // 替换数据
          node.value = pre.value;
          if( temp == node ){
              // 就是说 左转之后由于没有右子树，那么左转的结点就是node的前驱了，那么只需要接上 pre 的左子树（可能有，也可能没有）
              temp.left = pre.left;
          }else{
              // 就是说 找右边到尽头之后，这个 pre 肯定没有右子树了，至于左子树有没有不知道但是，按照有来做
              temp.right = pre.left;
          }
      }
  }
  ```

****

