# 1. 二叉排序树（查找树，搜索树）

## 1.1 二叉查找树的定义

什么是二叉查找树呢？它是具有一下性质的二叉树（关于二叉树请看我关于[二叉树定义](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%2B%E5%9F%BA%E7%A1%80%E4%BA%8C%E5%8F%89%E6%A0%91%E8%AF%A6%E8%A7%A3.md)的内容）:

* 若它的左子树不为空，那么它的左子树上的所有结点的值都小于它的根结点的值
* 若它的右子树不为空，那么它的右子树上的所有结点的值都大于（现在实际索引的算法设计中是 >=）它的根结点的值
* 他的左右子树是二叉查找树
* 它属于一种**动态**查找表

注意：在实际运用中，这个值的比较的大小是看你怎么定义的，当然数值的大小是通用的（不排除你对其特殊的定义）

如图：

![1539839046436](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539839046436.png)

## 1.2 二叉查找树具有的一些特点

* 使用中序遍历得到的结果是排好序的，比如上图，使用中序遍历的结果一定是递增的顺序排列

* 一个结点的直接前驱（中序遍历后的结果序列中这个结点值的前面一个，比如上图，中序遍历结果`15,17,18,19,21,40....`,21这个结点的直接前驱就是19这个结点。）如果这个结点在树中有左子树，

  先转左，然后找右到尽头，一定是它的前驱，如果转左之后没有右，那这个左就是他的前驱，（还是上图的例子21这个结点有左子树吧，转左刀15，然后找右到尽头，18，19，最后就找到了19；在看18这个结点由左子树，我们转左找到17，但是由于没有右子树了，所以这个17就是18的直接前驱）

* 一个结点的直接后继：知道了直接前驱，那么直接后继就不需要过多说明了，和直接前驱的正好相反。

**介绍直接前驱后继这个特点主要是因为，删除这个操作的算法设计要用到这样一个特点**

## 1.3 二叉查找树的查找过程

**注意**：我们知道它是一种动态查找表，也就是说这个树中的结点是可以增改的。那么它的增删改的过程肯定也是会查找这个动作。

**当一个二叉查找树不为空的时候，如有一个给定值A和根节点的关键字作比较，若想等那么查找成功，否则根据A与当前根结点关键字的大小关系决定去左子树还是右子树进行查找。**

**通常我们使用二叉链表来作为二叉搜索树的存储结构**

## 1.4 优缺点

* 优点：

  * 从他的一个定义以及查找过程，能很容易的看出来，它也是一种二分搜索的实现，不过相比于顺序查找表，的结构以及访问方式它的优势就很大了，就算顺序表使用了二分查找，斐波那契查找，插值查找，也是比不了二分搜索树的查找效率的，但是这里不是说它就是最好的查找表，当然顺着发展，我们有了更多更好用，更加符合我们当前需求的查找结构，但是这个是基础，他可以帮助我们理解后面的发展出来的更好的用于查找的数据结构。
  * **二叉查找树使用中序遍历，是可以拿到一个排序好的的序列的。红黑树也有这样的性质（但是他对基础的这个二叉排序树的设计做了进一步改进），左子树比根节点小，右子树比根节点大。相信从这里你能看出，java中TreeMap是怎么排序的了**

* 缺点：这里有一个国外的数据结构的学习，了解网站，[Binary Search Tree](https://www.cs.usfca.edu/~galles/visualization/BST.html) 我在上面做了一下模拟，基于上文中的二叉排序树的图的内容，按照不同顺序插入：

  * `40,15,21,19,18，17`：进行到这我就没有在进行下去了，原因呢看图：

    ![1539840633788](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539840633788.png)

    我们在看我们原来的图深度是5，这里你会说，深度代表什么，那么我们用一个直观的例子来说 : 在原来的图的二叉搜索树中我们要查找17这个值，我们只需要经过5次判断，就可以确定这个值存在；在现在这个结构中呢，需要6次；这样我们就能只管的看出，二叉排序树的缺点了吧，**表中数据动态变化不可控，相同的数据按照不同的顺序传入，得到的结果大不相同，在现在的存储系统中大量用到索引，如果选择这样的结构的，绝对会成为检索的性能瓶颈，而且你要知道这个所用的动态改变，也是会先做检索，然后才增删改的，这样的结构做什么操作的性能在实际运用中都不会是好的选择**；

    下面我会再次用一个极端的例子，让你们更加深刻的理解到这种结构的问题，这里我们按照这样的顺序插入数据：`15，17，18，19，21，40，56，60，68，100`

    ![1539841346239](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539841346239.png)

    看到这个结果什么感受，所以这种结构只能作为一个理论基础，在实际运用中是不会采用的。 

  **总结**：针对二叉排序树这样的缺点，人们就想到了在构造他的时候要去做**“平衡化”处理**，这也就有了平很二叉树的定义，在本文第2节，我会介绍平衡二叉树，以及对二叉排序树进行平衡化处理得到的**平衡二叉排序（查找，搜索）树**

## 1.5 二叉查找树的增删

增（insert）就不用说了吧，利用查找去做，然后没有别的特别的东西

这里主要说一下删(delete),为什么要说这个呢，是因为需要介绍在删除之后，要保持二叉排序树的中序遍历的结果中结点的前后顺序不变（这里就叫做稳定性了，后文中我都把它叫做稳点性）。

分下面三种情况讨论：（P代表双亲结点，PL代表它的左子树，PR代表它的右子树）

* 若结点 P 为叶子结点，删除叶子结点不破坏整个树的结构

* 若结点 P 只有左子树PL或者只有右子树PR，只需要将P的双亲结点指向P的指针指向PL或PR。

* 若左右子树不为空为了保证 “ 稳定性 ”，可以有两种做法，为了更加直观我们用一个树来演示：

  ![1539870820922](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539871115161.png)

  **中序遍历的结果：`29,35,36,37,47,49,51,56,58,62,73,88,99`**

  **假设这里我们要删除47**

  **注意观察树的深度变化**

  * 第一种是将P的双亲结点指向P的指针指向PL，将PR作为P的直接前驱的PR，结果：

    

    ![1539871310522](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539871310522.png)

    **树的深度是6**

  * 第二种做法是，令改结点P的直接前驱（或直接后继）替代P的位置，（查找直接前驱和后记的方法在上文1.2节当中有介绍），然后用这个直接前驱（直接后继）的双亲结点序接这个直接前驱（直接后继）的做子树或者右子树（这里我为什么用或呢？请你结合我前面说的前驱（后继）的特点来思考一下,虽然下文1.6节的算法代码中我有做说明），下面我分别给出用 前驱或后继 得到的结果图

    * 使用前驱得到的结果图

      ![1539872531318](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539872531318.png)

    * 使用后继得到的结果图

    ![1539872603495](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539872603495.png)

    **使用前驱（后继）两种方法修改的后二叉树的深度要么不变，要么减少（都会达到这样的效果）,显而易见，我们在实现的使用应该选择前驱（后继）的方式实现算法**

## 1.6 java 实现的删除树中一个结点的算法

* 使用前驱的算法：

  ```java
  public static BinaryLinkedNode delete(BinaryLinkedNode node) {
      BinaryLinkedNode temp = node;
      if (node.right == null) {
          // 右子树为空，只需要接上左子树
          node = node.left;
      } else if (node.right == null) {
          // 左子树为空，只需要接上右子树
          node = node.right;
      } else {
          // 左右子树都不为空
          BinaryLinkedNode pre = node.left;// 左转
          while (pre.right != null) {
              // 找右刀到尽头
              temp = pre;//用来记录 pre 的双亲
              pre = pre.right;
          }
          // 替换数据
          node.value = pre.value;
          if( temp == node ){
              // 就是说 左转之后由于没有右子树，那么左转的结点就是node的前驱了，那么只需要接上 pre 的左子树（可能有，也可能没有）
              temp.left = pre.left;
          }else{
              // 就是说 找右边到尽头之后，这个 pre 肯定没有右子树了，至于左子树有没有不知道但是，按照有来做
              temp.right = pre.left;
          }
      }
  }
  ```



* 使用后继的算法：

  ```java
  public static BinaryLinkedNode delete(BinaryLinkedNode node) {
      BinaryLinkedNode temp = node;
      if (node.right == null) {
          // 右子树为空，只需要接上左子树
          node = node.left;
      } else if (node.right == null) {
          // 左子树为空，只需要接上右子树
          node = node.right;
      } else {
          // 左右子树都不为空
          BinaryLinkedNode pre = node.left;// 左转
          while (pre.right != null) {
              // 找右刀到尽头
              temp = pre;//用来记录 pre 的双亲
              pre = pre.right;
          }
          // 替换数据
          node.value = pre.value;
          if( temp == node ){
              // 就是说 左转之后由于没有右子树，那么左转的结点就是node的前驱了，那么只需要接上 pre 的左子树（可能有，也可能没有）
              temp.left = pre.left;
          }else{
              // 就是说 找右边到尽头之后，这个 pre 肯定没有右子树了，至于左子树有没有不知道但是，按照有来做
              temp.right = pre.left;
          }
      }
  }
  ```

# 2 平衡二叉查找（排序，搜索）树

## 2.1 平衡二叉树

平衡二叉树出现的原因，我在1.4节最后的总结里面做了介绍，这里不在重复说明。我们直接看平衡二叉树的定义：

* 它的左右子树都是平衡二叉树
* 左子树和右子树的深度之差的绝对值绝对超过1

## 2.2 平衡二叉树的平衡因子

* **一个结点的平衡因子 = 该结点左子树深度 - 该结点的右子树深度**
* **那么平衡二叉树的所有结点的平衡因子取值只能是（-1，0，1），不再这范围，那就说明该二叉树失衡**

## 2.3 利用平衡因子画出来的二叉树的树图

* 平衡二叉树的平衡因子树图：

  ![1539917345242](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539917680023.png)

  ![1539917402506](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539917402506.png)

* 非平衡二叉树的平衡因子树图：

  ![1539917513301](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539917513301.png)

## 2.4 平衡二叉查找树的插入过程

我这我先介绍他用于平衡的旋转过程，然后再用一个实际的例子加上，图，算法，来说明。

我们在平衡二叉查找树的插入过程中，基本的插入和二叉查找树的插入有事一样的，主要需要做的是” 平衡化“处理，如何在插入一个结点，导致一个树失衡的情况下进行”平衡化“，**首先我们知道，我们做这个平衡只需要争对失衡的子树就可以了**，在知道这里的前提下，我们怎么去平衡子树呢，调整的规律可以归纳为下面四种情况。

* **单向右旋平衡**：由于在结点 P 的左子树为根节点的左子树上插入结点，导致了结点P失衡，平衡因子变为了2，那么我们需要经过一次右旋来使得以P为root的二叉树恢复平衡。那么我们现在用图来解释

  ![1539922215775](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539922215775.png)

  上图的平衡二叉查找树中我们插入一个 35 ， 得到下图，很明显我们发现下图的的树已经失衡了

  ![1539922356184](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539922356184.png)

  

  失衡的树是 50 为root的树，所以我们只要针它就可以了，这时候你们肯定会问怎么右旋，用什么做中心，下面我来讲解，**右旋就是，将失衡的树的 root结点，以他的左子树为中心，顺时针旋转，作为他的左子树的右子树，同时这个原root结点的左子树 指向它原左子树的右子树。**

  **直观的感受下**：上述情况50 作为root的树失衡，根据上文我们说的右旋过程，将这个旋转的中心首先确定下来是他的左子树，也就是 40 这个结点，将 50 这个结点顺时针旋转下来作为 40 这个结点的右子树，然后将50结点的左子树指向40 结点 的右子树42，最后得到了恢复平衡后的 平衡二叉查找树：

  ![1539923163210](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539923163210.png)

  

**可以看到，这个最终平衡化之后的树的深度和没有插入35这个结点之前的树的深度是一样的**

* **单向左旋平衡**：由于在结点 P 的右子树为根节点的右子树上插入结点，导致了结点P失衡，平衡因子变为了-2，那么我们需要经过一次左旋来使得以P为root的二叉树恢复平衡。那么我们现在用图来解释

![1539923756815](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539923756815.png)

上图的平衡二叉查找树中我们插入一个 68 ， 得到下图，很明显我们发现下图的的树已经失衡了

![1539923918707](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539923918707.png)

我们 40 为root的树，的you所以我们只要针它就可以了，这时候你们肯定会问怎么左旋，用什么做中心，下面我来讲解，**左旋就是，将失衡的树的 root 结点，以他的右子树为中心，逆时针旋转，作为他的右子树的左子树，同时这个原root结点的右子树 指向它原右子树的左子树。**

**直观的感受**：上述情况40作为root的树失衡，根据上文我们说的左旋过程，将这个旋转的中心首先确定下来是他的右子树，也就是 50 这个结点，将 40 这个结点逆时针旋转下来作为 50 这个结点的左子树，然后将40结点的右子树指向50 结点 的左子树42，最后得到了恢复平衡后的 平衡二叉查找树：

![1539924441756](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539924441756.png)

**不知道你们有没有细心的发现一些规律，**

1. 旋转的中心结点，和需要调整的树的根结点，在调整之后平衡因子都变成了0
2. 插入结点的时候，往左边，树的根结点的平衡因子+1
3. 插入结点的时候，往右边，树的根结点的平衡因子-1
4. 一个树的根结点的平衡因子为1，在给它插入一个结点是走向他的左子树，并且他的左子树的平衡因子也是1，这时候1+1=2 ， 树失衡了，
5. 需要左旋的

* **双向旋转（先右后左）**：由于在结点 P 的右子树为根节点的左子树上插入结点，导致了结点P失衡，平衡因子变为了-2，那么我们需要经过两次旋转（先右旋再左旋）来使得以P为root的二叉树恢复平衡。那么我们现在用图来解释

  ![1539923756815](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539923756815.png)

  上图的平衡二叉查找树中我们插入一个 39 ， 得到下图，很明显我们发现下图的的树已经失衡了

  ![1539939630223](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539939630223.png)

  **将失衡的树的 root 结点，先将root的右子树进行右旋操作，然后在对root为根结点的树进行左旋。**

  **直观的感受**：上述情况40作为root的树失衡，根据上文我们说的先右后左的过程，首先对40结点的右子树，进行右旋操作（旋转过程和前面的是一样的，在这里我就不再次说明），得到图：

  ![1539940360816](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539940360816.png)

  然后我们在对其 40结点的树进行左旋，得到图：

  ![1539940529483](https://github.com/Alan-Jun/study-note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/assets/1539940529483.png)

  

* **双向旋转（先左后右）**：由于在结点 P 的左子树为根节点的右子树上插入结点，导致了结点P失衡，平衡因子变为了2，那么我们需要经过两次旋转（先左旋再右旋）来使得以P为root的二叉树恢复平衡。过程和上面 先右在左的正好相反，我就不继续说明了。