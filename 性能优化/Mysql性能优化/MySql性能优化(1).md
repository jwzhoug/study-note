# 说明

第一块做架构的介绍，原因：

* 首先要对mysql有一个整体的意识
* 其次我们能对mysql里面的一些概念更加理解，帮助我们做优化的时候分析问题
* 知道我们优化的是mysql内部的哪些部分

# 1 Mysql 整体架构图

![20170320171720213](E:\文档\study-note\study-note.assets/20170320171720213.png)

我们平时使用的都是上面的Client层，也就是客户端

要了解Mysql的性能优化，那么我们需要知道的是Mysql的服务端怎么运作的，以及它的存储引擎。

上图server部分的简图：

![1540258068280](E:\文档\study-note\性能优化\Mysql性能优化\assets\1540258068280.png)

# 2 细化的流程交互图

我们创建连接到执行sql的整个流程图就是下图了。

* 初始化模块：启动mysql服务的时候，会根据一些参数去做mysql服务的初始化
* 连接管理模块：顾名思义是用作连接管理的，用过java的jdbc的应该对连接不陌生，我就不做说明了

sql执行部分，需要经过：

1. **连接管理模块**
2. **连接进程模块**：mysql内部的一个类似线程池的模块
3. **用户模块**：检查权限
4. **命令分发器** ：
5. **命令解析器** ：这里我们可以看到有多个分支走向：
   * **查询优化器**：顾名思义，我就不做讲解了
   * **表变更模块**：执行 DML 语句 将会进入这个分支（不知道什么是DML的后文的补充说明章节）
   * **表维护模块**：执行 DDL 语句 将会进入这个分支（不知道什么是DDL的后文的补充说明章节）
   * **复制模块**：比如主从复制
   * **状态模块**：比如 show status like '%cache%' 这样的语句
6. **访问控制模块**
7. **表管理模块**
8. **存储引擎接口**
**细心的你肯定看到了，命令分发器左边有走向一个 查询换存模块 **，相信大家再做查询的时候会发现执行同一条语句，做二次查询的时候性能快了很多，这就是查询换存的作用了，第一次查询之后，得到的数据会换存在这个模块中，当然它是有大小限制的，所以在有的时候，可以调大这个换存的参数，起到一定的优化作用。





![1540258115396](E:\文档\study-note\性能优化\Mysql性能优化\assets\1540258115396.png)

# 3 SQL 优化

在了解到第2章的内容之后，那么我们SQL优化的操作是针对的哪些模块应该有一个大致的了解了：

* **命令解析器**：
  * **查询优化器**：顾名思义，我就不做讲解了
  * **表变更模块**：执行 DML 语句 将会进入这个分支（不知道什么是DML的后文的补充说明章节）

主要针对的就是上面的两个模块

**当然，要做这样的优化，我们还需要了解，数据库的引擎的原理，因为为什么做这样的优化，是由底层设计决定的**

# 4 MySql 引擎

这里我们介绍MYSql现在主流的引擎

![1540260679767](E:\文档\study-note\性能优化\Mysql性能优化\assets\1540260679767.png)

## 4.1 Innodb 

从上文中可以看到`Innodb`索引和数据存在一个文件中



## 4.2 Myisam

`Myisam`索引和数据文件是分开的

## 4.3 建表如何指定使用什么数据引擎呢

```sql
 create table test(
 id int(10) unsigned not null auto_increment,
 name varchar(10) character set utf8,
 age int(10),
 primary key(id)
 )
engine=MyISAM --INNODB
;

```

## 4.4 如何更改表的数据引擎

```sql
alter table test engine=innodb;
```

# 5 Mysql中的索引

## 5.1 什么是索引

**索引是高效获取数据的数据结构，在数据存储系统中索引以文件形势存在。**

这里介绍一部分mysql中所用到的索引

* hash :  不建议使用，也最好不要用。原因：
  * 因为hash容易产生hash冲突
  * **无法做范围查询，只能做等值查询的索引，不符合实际运用情况**, 比如：select * from table where id > 1
* FullText ：类似全文检索的索引
* R Tree:空间索引，一般不涉及到那样的也为用不到
* B Tree:
* B+Tree: mysql的InnoDB和MYSAM引擎都是走的 B+Tree 索引

## 5.2

## 5.3 创建索引需要注意什么

* 较频繁的作为查询条件的字段**应该创建索引**，索引怎么创建

* 唯一性太差（数据重复率太高）的字段**不适合创建索引**
* 更新非常频繁的字段**不适合创建索引**
* 不会出现在where子句中的字段**不适合创建索引**

# 6 SQL 执行计划

## 6.1 什么是执行计划？

执行计划 ： 数据库根据SQL语句和相关表的统计信息作出的查询方案，该方案由查询优化器自动解析产生
比如，一条SQL语句是从10条数据中查询一条数据，正常情况 查询优化器 会选择索引查找的方
式。  如果此时你的SQL语句使用不当 那么很可能就要进行全表扫描了

## 6.2 怎么看执行计划？

在select语句之前 加上`explain`:

比如：`EXPLAIN select * from goods where price = 70`

增删改语句也可以变相的使通过`explain`来查看执行计划，因为增删改也是带有查询语句的，比如

`update goods set price = 100 where goodId=2 `

这时候我们可以通过`EXPLAIN select * from goods where goodId=2 `,来查看执行计划，看是否按照你所想要的结果高效执行

**那么 sql 查询中 为了提高查询效率 ， 需要注意的什么呢？**

## 6.3 通过查看执行计划总结得出：

1. 首先需要写出 统一 的 sql 语句 举例：
    * select * from tablename
    * select * FROM tablename

    虽然只是大小写不同 ，但是查询分析器 就认为这是两个不同的sql 语句，他需要去解析两次，生成两个执行计划

    所以我们 在写程序的时候 应该去保证同样的 SQL语句 在任何地方都是一致的。多一个空格都不可以

2. 尽量不要把 SQL语句 写的太长，太过冗余

     根据经验嵌套超过三层，查询优化器就很容易给出错误的执行计划。另外执行计划是可以复用的，越是简单的SQL语句复用的可能性越高。 而复杂的SQL语句只要有一个字符发生变化，就必须重新解析。然后这样的垃圾信息，还会被缓存在内存中，可想而知，数据库的性能会受到多大影响

3. 合理使用 like 模糊查询

     like '%xxx' 这样的 % 号出现在关键字前面的模糊查询 肯定会走全表扫描，因此 除非必要，否则不要在关坚持前面加%。

4. 应该尽量避免在 where 字句中 对字段进行 null 值得判断 不管是 is null / is not null

   比如 : select id from table where name is null     假设 这个表我们对 name 设置
   了索引，但是 查询分析器不会使用索引，因此查询效率低下。为了避免这样的情况发生，我们应该设置表的值为0或'’根据你字段类型来设置一个值，不管怎么也别是null.这样就可以 通过 判断 name = 0 或则是 name = ...‘’来过滤了

5. 避免在 where 字句中 使用 不等于 ！= 或则 <> 这样的操作符

     比如 : select id from table where name != 0

     使用这种查询条件操作符 不会使用索引，而 > , >= , < , <= , = , between and ,这样的操作符，数据库才会使用
     索引。那么该sql 应该写成 select id from table where name > 0 union all select id from table where name <0

6. 为什么 上述5的 优化后sql 不适用 or 呢 ， 因为 我们也需要避免在 SQL语句中 使用 or 来连接条件

7. 少用 in 或 not in  ，在子查询当中用 exists 代替 in 是一个好的选择

8. 避免在 where 字句中进行 函数 或 表达式 操作

    比如：

    * select id from table where name/2 = 50
    * select id from table where substring(name,1,8) = 'xxxx'

9. 在子查询当中 用 exists 代替 in 是一个好的选择

10. count(*) 这样不带任何条件的 count 会导致全表扫描

# 6 性能优化

## 6.1 影响性能的因素

* 人为因素 : 考虑自己的需求设计是否合理 ; 结构，架构设计是否合理。............
* sql : 这个就需要用到前面的知识做优化了

# 补充说明

## 数据库语句大致分类

* **DML (Data Munipulation language)** : 数据操作语言 对表的增删改这些语句

* **DDL (Data Definition language)** : 据库定义语言 比如：create , alter , drop , 等语句

* **DCL (Data Control language ) ** : 数据库控制语言 用来设置或更改数据库用户或者较色权限的语句 比如: grant , deny , revoke 等

  