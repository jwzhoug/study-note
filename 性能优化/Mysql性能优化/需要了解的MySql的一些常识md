# 事务需要遵循的原则：ACID
*  Automicity  原子性 ：事务要么被全部执行，要么全不被执行。如果事务下的子事务全部提交成功，则所有数据库操作被提交，否则应该进行事务回滚。

  **计算机中很多地方（比如编程中）都需要一些保证原子性的实现，一个需要执行完所有的操作才有意义的操作集合，就可以实现成原子性的**

* Consistency 一致性：事务应该确保数据库状态从一个一致状态转变为另一个一致性状态

  计算机中很多地方（比如编程（多线程）中，cpu工作机制中（多指令并行）需要保证最后的结果是这些所有操作时候的最终结果…..）
  简单的例子：现在有6个人 每人有一个账号，他们之间会相互转账，这样就组成了一个小的数据系统，那么什么事一致性呢？这是个人定义的，比如这几个人账号的总金额不变，那就是一致的，反之不一致。 再比如 现在数据时分布式存储的，有一个数据在几个地方都保存了，那么任何时候这几个地方的数据都必须相同，这也是一致性。

* Isolation 隔离性：事务相互间不能被影响(多线程中一些情况也是需要实现隔离性的)

* Durabillity 持久性：事务一旦提交之后将他对数据库的操作应该是永久性的，即便出现其他故障，事务处理结果也应不被影响。

  

# 在并发执行事务时会发生什么问题呢？



1、丢失更新：撤销一个事务时，把其他事务已提交的更新数据覆盖（事务A和B并发执行，A事务执行更新后，提交；B事务在A事务更新后，B事务结束前也做了对该行数据的更新操作，然后回滚，则两次更新操作都丢失了）。

2、脏读：一个事务读到另一个事务未提交的更新数据（事务A和B并发执行，B事务执行更新后，A事务查询B事务没有提交的数据，B事务回滚，则A事务得到的数据不是数据库中的真实数据。也就是脏数据，即和数据库中不一致的数据）。

3、不可重复读：一个事务读到另一个事务已提交的更新数据（事务A和B事务并发执行，A事务查询数据，然后B事务更新该数据，A再次查询该数据时，发现该数据变化了）。

4、覆盖更新：这是不可重复读中的特例，一个事务覆盖另一个事务已提交的更新数据（即A事务更新数据，然后B事务更新该数据，A事务查询发现自己更新的数据变了）。

# 隔离级别

1.       Serializable (序列化，串行化) : 串行执行 可避免脏读，不可重复读，幻读的发生。它是最高的事务隔离级别，同事花费的代价也是很大的，性能很低，一般很少使用。

2. Repeatable read (重复读) :一个事务开始读取这条数据，那么别的事务就不能对其进行修改。 可以解决不可重复读和脏读

* Read committed (读已提交): 一个事物要等另一个事务提交之后才能读取 可避免脏读 

* Read uncommitted(读未提交) 

  **mysql 默认是 `REPEATABLE-READ` 重复读**

# 如可查看级别

* 查看当前会话隔离级别

  `select @@tx_isolation;`

* 查看系统当前隔离级别

  `select @@global.tx_isolation;`

* 设置当前会话隔离级别

  `set session transaction isolatin level repeatable read;`

* 设置系统当前隔离级别

  `set global transaction isolation level repeatable read;`

# 什么是唯一索引

创建唯一索引的目的不是为了提高访问速度，而只是为了避免数据出现重复。唯一索引可以有多个但索引列的值必须唯一，索引列的值允许有空值。**如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该使用关键字UNIQUE，把它定义为一个唯一索引。** 



