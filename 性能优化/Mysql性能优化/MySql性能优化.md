# 说明

第一块做架构的介绍，原因：

* 首先要对mysql有一个整体的意识
* 其次我们能对mysql里面的一些概念更加理解，帮助我们做优化的时候分析问题
* 知道我们优化的是mysql内部的哪些部分

# 1 Mysql 整体架构图

![20170320171720213](E:\文档\study-note\study-note.assets/20170320171720213.png)

我们平时使用的都是上面的Client层，也就是客户端

要了解Mysql的性能优化，那么我们需要知道的是Mysql的服务端怎么运作的，以及它的存储引擎。

上图server部分的简图：

![1540258068280](E:\文档\study-note\性能优化\Mysql性能优化\assets\1540258068280.png)

# 2 细化的流程交互图

我们创建连接到执行sql的整个流程图就是下图了。

* 初始化模块：启动mysql服务的时候，会根据一些参数去做mysql服务的初始化
* 连接管理模块：顾名思义是用作连接管理的，用过java的jdbc的应该对连接不陌生，我就不做说明了

sql执行部分，需要经过：

1. **连接管理模块**
2. **连接进程模块**：mysql内部的一个类似线程池的模块
3. **用户模块**：检查权限
4. **命令分发器** ：
5. **命令解析器** ：这里我们可以看到有多个分支走向：
   * **查询优化器**：顾名思义，我就不做讲解了
   * **表变更模块**：执行 DML 语句 将会进入这个分支（不知道什么是DML的后文的补充说明章节）
   * **表维护模块**：执行 DDL 语句 将会进入这个分支（不知道什么是DDL的后文的补充说明章节）
   * **复制模块**：比如主从复制
   * **状态模块**：比如 show status like '%cache%' 这样的语句
6. **访问控制模块**
7. **表管理模块**
8. **存储引擎接口**
**细心的你肯定看到了，命令分发器左边有走向一个 查询换存模块 **，相信大家再做查询的时候会发现执行同一条语句，做二次查询的时候性能快了很多，这就是查询换存的作用了，第一次查询之后，得到的数据会换存在这个模块中，当然它是有大小限制的，所以在有的时候，可以调大这个换存的参数，起到一定的优化作用。





![1540258115396](E:\文档\study-note\性能优化\Mysql性能优化\assets\1540258115396.png)

# 3 SQL 优化

在了解到第2章的内容之后，那么我们SQL优化的操作是针对的哪些模块应该有一个大致的了解了：

* **命令解析器**：
  * **查询优化器**：顾名思义，我就不做讲解了
  * **表变更模块**：执行 DML 语句 将会进入这个分支（不知道什么是DML的后文的补充说明章节）

主要针对的就是上面的两个模块

**当然，要做这样的优化，我们还需要了解，数据库的引擎的原理，因为为什么做这样的优化，是由底层设计决定的**

# 4 MySql 引擎

这里我们介绍MYSql现在主流的引擎

![1540260679767](E:\文档\study-note\性能优化\Mysql性能优化\assets\1540260679767.png)

## 4.1 Innodb 

从上文中可以看到`Innodb`索引和数据存在一个文件中，存储形势：

![1540277142005](E:\文档\study-note\性能优化\Mysql性能优化\assets\1540277142005.png)

## 4.2 Myisam

`Myisam`索引和数据文件是分开的，存储的形势是这样的，最后在B+Tree 的叶子节点上面会有数据的逻辑地址

![1540277065342](E:\文档\study-note\性能优化\Mysql性能优化\assets\1540277065342.png)

## 4.3 建表如何指定使用什么数据引擎呢

```sql
 create table test(
 id int(10) unsigned not null auto_increment,
 name varchar(10) character set utf8,
 age int(10),
 primary key(id)
 )
engine=MyISAM --INNODB
;

```

## 4.4 如何更改表的数据引擎

```sql
alter table test engine=innodb;
```

# 5 Mysql中的索引

## 5.1 什么是索引

**索引是高效获取数据的数据结构，在数据存储系统中索引以文件形势存在。**

这里介绍一部分mysql中所用到的索引

* hash :  不建议使用，也最好不要用。原因：
  * 因为hash容易产生hash冲突
  * **无法做范围查询，只能做等值查询的索引，不符合实际运用情况**, 比如：select * from table where id > 1
* FullText ：类似全文检索的索引
* R Tree:空间索引，一般不涉及到那样的也为用不到
* B Tree:
* B+Tree: mysql的InnoDB和MYSAM引擎都是走的 B+Tree 索引

## 5.3 什么是聚集索引

这个就要看他的索引存储方式：

* 在`Innodb`中索引和数据同时存在一块的就是聚集索引
* 在`MyISAM`中索引和数据分离的就是非聚集索引

**具体的看第4节的内存帮助理解**

## 5.4 联合（复合）索引

### mysql索引最左匹配原则的理解

内容完全来自 https://blog.csdn.net/qq_24690761/article/details/52787897

**首先我们创建一个表，有三个字段，分别是id,name,cid**

```sql
CREATE TABLE `student` (
	`id` INT (11) NOT NULL AUTO_INCREMENT,
	`name` VARCHAR (255) DEFAULT NULL,
	`cid` INT (11) DEFAULT NULL,
	PRIMARY KEY (`id`),
	KEY `name_cid_INX` (`name`, `cid`),

) ENGINE = INNODB AUTO_INCREMENT = 8 DEFAULT CHARSET = utf8
```

索引方面：id是主键，(name,cid)是一个多列索引(联合索引)。

**下面是我们有疑问的两个查询：**

```sql
EXPLAIN SELECT * FROM student WHERE cid=1;

EXPLAIN SELECT * FROM student WHERE cid=1 AND name='小红';
```

疑问是：sql查询用到索引的条件是必须要遵守最左前缀原则，为什么上面两个查询还能用到索引？

讲上面问题之前，我先补充一些知识，因为我觉得你对索引理解是狭隘的：

上述你的两个查询的explain结果中显示用到索引的情况类型是不一样的。,可观察explain结果中的type字段。你的查询中分别是：

1. type: index
2. type: ref

**解释：**

index：这种类型表示是mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个复合索引的一部分，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。

所以：对于你的第一条语句：

EXPLAIN SELECT * FROM student WHERE cid=1;

判断条件是cid=1,而cid是(name,cid)复合索引的一部分，没有问题，可以进行index类型的索引扫描方式。explain显示结果使用到了索引，是index类型的方式。

ref：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一 一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。

有些了解的人可能会问，索引不都是一个有序排列的数据结构么。不过答案说的还不够完善，那只是针对单个索引，而复合索引的情况有些可能就不太了解了。

**下面就说下复合索引：**

mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。

所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的，当然，可能会出现上面的使用index类型的索引。这就是所谓的mysql为什么要强调最左前缀原则的原因。

**那么什么时候才能用到呢?**

当然是cid字段的索引数据也是有序的情况下才能使用咯，什么时候才是有序的呢？观察可知，当然是在name字段是等值匹配的情况下，cid才是有序的

这也就是mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。

所以对于你的这条sql查询：

```sql
EXPLAIN SELECT * FROM student WHERE cid=1 AND name='小红';
```



没有错，而且复合索引中的两个索引字段都能很好的利用到了！因为语句中最左面的name字段进行了等值匹配，所以cid是有序的，也可以利用到索引了。

你可能会问：我建的索引是(name,cid)。而我查询的语句是cid=1 AND name='小红'; 我是先查询cid，再查询name的，不是先从最左面查的呀？

好吧，我再解释一下这个问题：首先可以肯定的是把条件判断反过来变成这样 name='小红' and cid=1; 最后所查询的结果是一样的。

那么问题产生了？既然结果是一样的，到底以何种顺序的查询方式最好呢？

所以，而此时那就是我们的mysql**查询优化器**该登场了，mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以mysql查询优化器会最终以这种顺序进行查询执行。

## 5.2 使用索引的优缺点

**优点：**

* 提高检索效率
* 降低排序成本——排序/分组主要消耗的是我们的内存和cpu

**缺点：**(**创建的表的索引越多,下面这些情况越明显**)

* 增大数据更新(增删改)时候的IO量,你更新数据索引也是需要同步更新的
* 增加更新的时候索引调整的计算量
* 占用的内存会更多(多数情况多不会考虑这一点,主要还是考虑上面的情况)

**在一些特定情况下,如果一张表索引太多,可以考虑使用联合索引(使用它就要考虑自己的sql的设计,参考5.4节),用以减少索引数量**

## 5.3 创建索引需要注意什么

* 较频繁的作为查询条件的字段**应该创建索引**，索引怎么创建

* 唯一性太差（数据重复率太高）的字段**不适合创建索引**
* 更新非常频繁的字段**不适合创建索引**
* 不会出现在where子句中的字段**不适合创建索引**
* **我们选择什么做主键比较好**：能选择自增id做主键是最好的情况，从B+Tree的插入过程原理，可以知道使用自增组件做插入的时候，我们的插入和分裂过程都集中到右子树，同时插入一边都是到最右边的叶子节点，同时分裂，也是针对那一部分，
* 非

# 6 SQL 执行计划

## 6.1 什么是执行计划？

执行计划 ： 数据库根据SQL语句和相关表的统计信息作出的查询方案，该方案由查询优化器自动解析产生
比如，一条SQL语句是从10条数据中查询一条数据，正常情况 查询优化器 会选择索引查找的方
式。  如果此时你的SQL语句使用不当 那么很可能就要进行全表扫描了

## 6.2 怎么看执行计划？

在select语句之前 加上`explain`:

比如：`EXPLAIN select * from goods where price = 70`

增删改语句也可以变相的使通过`explain`来查看执行计划，因为增删改也是带有查询语句的，比如

`update goods set price = 100 where goodId=2 `

这时候我们可以通过`EXPLAIN select * from goods where goodId=2 `,来查看执行计划，看是否按照你所想要的结果高效执行

**那么 sql 查询中 为了提高查询效率 ， 需要注意的什么呢？**

## 6.3 通过查看执行计划总结得出：

1. 首先需要写出 统一 的 sql 语句 举例：
    * select * from tablename
    * select * FROM tablename

    虽然只是大小写不同 ，但是查询分析器 就认为这是两个不同的sql 语句，他需要去解析两次，生成两个执行计划

    所以我们 在写程序的时候 应该去保证同样的 SQL语句 在任何地方都是一致的。多一个空格都不可以

2. 尽量不要把 SQL语句 写的太长，太过冗余

     根据经验嵌套超过三层，查询优化器就很容易给出错误的执行计划。另外执行计划是可以复用的，越是简单的SQL语句复用的可能性越高。 而复杂的SQL语句只要有一个字符发生变化，就必须重新解析。然后这样的垃圾信息，还会被缓存在内存中，可想而知，数据库的性能会受到多大影响

3. 合理使用 like 模糊查询

     like '%xxx' 这样的 % 号出现在关键字前面的模糊查询 肯定会走全表扫描，因此 除非必要，否则不要在关坚持前面加%。

4. 应该尽量避免在 where 字句中 对字段进行 null 值得判断 不管是 is null / is not null

   比如 : select id from table where name is null     假设 这个表我们对 name 设置
   了索引，但是 查询分析器不会使用索引，因此查询效率低下。为了避免这样的情况发生，我们应该设置表的值为0或'’根据你字段类型来设置一个值，不管怎么也别是null.这样就可以 通过 判断 name = 0 或则是 name = ...‘’来过滤了

5. 避免在 where 字句中 使用 不等于 ！= 或则 <> 这样的操作符

     比如 : select id from table where name != 0

     使用这种查询条件操作符 不会使用索引，而 > , >= , < , <= , = , between and ,这样的操作符，数据库才会使用
     索引。那么该sql 应该写成 select id from table where name > 0 union all select id from table where name <0

6. 为什么 上述5的 优化后sql 不适用 or 呢 ， 因为 我们也需要避免在 SQL语句中 使用 or 来连接条件

7. 少用 in 或 not in  ，在子查询当中用 exists 代替 in 是一个好的选择

8. 避免在 where 字句中进行 函数 或 表达式 操作

    比如：

    * select id from table where name/2 = 50
    * select id from table where substring(name,1,8) = 'xxxx'

9. 在子查询当中 用 exists 代替 in 是一个好的选择

10. count(*) 这样不带任何条件的 count 会导致全表扫描

# 6 性能优化

## 6.1 影响性能的因素

* 人为因素 : 考虑自己的需求设计是否合理 ; 结构，架构设计是否合理。............
* sql : 这个就需要用到前面的知识做优化了

# 补充说明

## 数据库语句大致分类

* **DML (Data Munipulation language)** : 数据操作语言 对表的增删改这些语句

* **DDL (Data Definition language)** : 据库定义语言 比如：create , alter , drop , 等语句

* **DCL (Data Control language ) ** : 数据库控制语言 用来设置或更改数据库用户或者较色权限的语句 比如: grant , deny , revoke 等

  